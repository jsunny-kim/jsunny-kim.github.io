---
title:  "클린 아키텍처 (2)"
category: posts
tags:
  - 클린 아키텍처
comments: true
last_modified_at: 2020-02-02T10:45:00
---

# 02. 벽돌부터 시작하기: 프로그래밍 패러다임

> 패러다임이란 프로그래밍을 하는 방법으로, 대체로 언어에는 독립적이다. 패러다임은 어떤 프로그래밍 구조를 사용할지, 그리고 언제 이 구조를 사용해야 하는지를 결정한다.

## 3장. 패러다임 개요

> 각 패러다임은 프로그래머에게서 권한을 박탈한다. 즉, 패러다임은 무엇을 해야 할지를 말하기보다는 무엇을 해서는 안 되는지를 말해준다.

### 구조적 프로그래밍(`structured programming`)

- 최초로 적용된 패러다임
- **제어흐름의 직접적인 전환**에 부과되는 규율

### 객체 지향 프로그래밍(`object-oriented programming`)

- **제어흐름의 간접적인 전환**에 부과하는 규율

### 함수형 프로그래밍(`functional programming`)

- 어떤 수학적 문제를 해결하는 과정에서 발명된 람다 계산법에 영향을 받음
- **변수 할당**에 부과되는 규율

### 생각할 거리 🤔

> 세 가지 패러다임의 규칙과 아키텍처 관심사(함수, 컴포넌트 분리, 데이터 관리) 와의 관계

## 4장. 구조적 프로그래밍

> 데이크스트라는 진공관 시대에 자신의 경력을 시작했는데, 이 시대는 컴퓨터가 거대하고, 쉽게 손상되며, 느린 데다가 결과마저 믿을 수 없는, 그래서 제한적으로만 사용될 때였다.

### 증명

​프로그램의 동작 및 결과가 올바르다는 것을 증명하기 위해 **분할 정복 접근법**을 사용하였다. 이는 모듈을 (입증된) 작은 단위로 재귀적으로 분해하여 코드가 올바르다는 것을 입증하는 방식을 의미하는데, 이 과정에서 제어흐름을 제약 없이 직접 전환하는 goto 문장은 모듈을 더 작은 단위로 분해하는 과정에 방해가 된다는 사실을 발견했다.

​반면 goto 문장을 사용하더라도 모듈 분해에 문제가 되지 않는 경우도 있었는데, **분기**와 **반복**문 제어구조가 여기에 해당한다. (우리는 이러한 제어 구조와 **순차** 실행을 결합하여 모든 프로그램을 표현할 수 있다.)

- **순차**(`selection`) : 단순한 열거법을 통해 증명
- **분기**(`iteration`) : 분기의 각 경로에 열거법을 적용하여 증명
- **반복**(`sequence`) : 귀납법을 통해 증명 (반복의 시작 조건과 종료 조건 및 1의 경우, N의 경우에 대해 열거법 적용)

### 기능적 분해

​구조적 분석(`structured analysis`)이나 구조적 설계(`structured design`)과 같은 기법을 통해 표현된 구조적 프로그램은 재귀적 분해 과정을 통해 고수준의 모듈, 컴포넌트 단위로 세분화하여 입증할 수 있다.

### 테스트

​하지만 세분화된 기능 전체를 엄밀히 증명하는 과정은 끝내 만들어지지 않았다. 결국 유클리드 방식과 같은 수학적 증명이 아닌 과학적 방법(`scientific method`)를 통해 입증하기로 한다.

​과학은 서술된 내용이 참임을 증명하는 방식이 아니라, 거짓임을 증명하는 과정을 통해 증명된다. 즉, 반례를 들 수 없는 서술이 있다면 해당 서술은 참임이 입증된다.

> 테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다.

​구조적 프로그래밍은 프로그램을 증명 가능한 단위로 세분화할 것을 강요한다. 그리고 나서 테스트를 통해 해당 기능을 증명하려고 노력해야 한다.

## 5장. 객체 지향 프로그래밍

> 객체 지향(`Object-Oriented`)의 본질을 설명하기 위한 세 가지 개념. **캡슐화**, **상속**, **다형성**.

### 캡슐화?

​객체 지향 언어는 데이터와 함수를 효과적으로 캡슐화하는 방법을 제공한다. `private`,  `public`, `protected`  표현을 통해 데이터와 함수를 은닉하고 일부 함수만 외부에 노출할 수 있다.

​이러한 캡슐화 개념은 사실 C 언어에서도 완벽하게 구현될 수 있다(데이터 구조와 함수가 선언되어 있는 헤더 파일과 구현 파일의 분리). 오히려 객체 지향 언어는 캡슐화를 거의 강제하지 않기 때문에 C 언어의 완벽한 캡슐화를 약화시켰다고도 할 수 있다. 

### 상속? 

> 사실 상속이란 단순히 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일에 불과하다.

​객체 지향 언어가 있기 이전에 C 프로그래머는 언어의 도움 없이 상속 개념을 직접 구현하여 사용했다. 하지만 이는 객체 지향 언어에서 제공하는 상속만큼 편리하지 않고, 다중 상속 개념 등을 직접 구현하는 일은 더욱 어려운 일이다.

### 다형성?

> 1940년대 후반 폰 노이만(Von Neumann) 아키텍처가 처음 구현된 이후 프로그래머는 다형적 행위를 수행하기 위해 함수를 가리키는 포인터를 사용해 왔다.

​객체 지향 언어가 있기 이전에도 함수를 가리키는 포인터들을 통해 다형성을 표현할 수 있었다. 하지만 함수 포인터는 위험하고, 구현하기 불편하다. 즉, 객체 지향 언어는 다형성을 새롭게 제공한 것은 아니지만, 더 안전하고 편리하게 사용할 수 있게 해준다.

**다형성이 가진 힘**

​객체 지향 언어의 등장으로 언제 어디서든 **장치 독립적인** 플러그인 아키텍처(`plugin architecture`) 적용할 수 있게 되었다. 

**의존성 역전**

> 객체 지향 언어가 다형성을 안전하고 편리하게 제공한다는 사실은 소스 코드 의존성을 어디에서든 역전시킬 수 있다는 뜻이기도 하다.

![](http://www.plantuml.com/plantuml/svg/SoWkIImgAStDuShCAqajIajCJbNmXBEgkRGLt4hpaaioy_CqDBbgkP9p4ekB5HnzyrDASr8LCdCBSb9pK_DAYWdhSOBeuOBI2hgwTd1D254zFJkOwLmEgNafG8S10000)
![](http://www.plantuml.com/plantuml/svg/SoWkIImgAStDuOeEzOnLqDMrKuXsAYtEp4ijBbO8Air9BOxbGXTGqDEpKm0gnoNZabYIc9HOd0gKXp5ncEoGcfS2j1i0)

​객체 지향 언어를 통해 소스 코드 의존성이 제어흐름의 방향과 일치되도록 제한되지 않고, 의존성 전부에 대해 방향을 결정할 수 있는 절대적인 권한을 갖는다.

## 6장. 함수형 프로그래밍

> 함수형 프로그래밍이라는 개념은 프로그래밍 그 자체보다 앞서 등장했다. 이 패러다임에서 핵심이 되는 기반은 람다(`lambda`) 계산법으로 알론조 처치(Alonzo Church)가 1930년대에 발명했다.

​함수형 언어에서 변수는 변경되지 않는다. 이는 자바 프로그램의 가변 변수와 극단적인 차이를 가진다.

### 불변성과 아키텍처

​경합 조건, 교착상태 조건, 동시 업데이트 문제는 모두 가변 변수로 인해 발생한다. 즉, 다수의 스레드와 프로세스를 사용하는 애플리케이션에서 직면하게 되는 모든 문제는 가변 변수가 없다면 절대로 생기지 않난다.

​단, 완벽한 불변성을 실현하기 위해서는 무한한 저장 공간과 무한히 빠른 프로세서 속도가 요구된다. 따라서 우리는 불변성 실현에 대해 어떤 타협이 필요하다.

### 가변성의 분리

![](http://www.plantuml.com/plantuml/svg/SoWkIImgAStDuKehIinDLL1wlQtZzUO6XJUxjxpjN_EwfUTjrmubXMgkQ6VJM21X0YACGOGHY32CvQe5IodewjefH2kzsj20eHciZP02Oq8AZ0WfCCIl08UuWWr44v3pUjwSD_FMlccTeV1wvPJNgrQyNhO6gCyXDIy563e0)

​불변성과 관련한 주요한 타협 중 하나는 애플리케이션 내부의 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이다. 불변 컴포넌트에서는 순수 함수형 방식의 작업만 존재한다. 불변 컴포넌트는 변수의 상태 변경을 위해 하나 이상의 다른 컴포넌트와 서로 통신한다. 여기서 상태 변경을 통해 컴포넌트가 동시성 문제에 노출되지 않도록, 트랜잭션 메모리(`transactional memory`)와 같은 실천법을 사용하여 동시성 문제로부터 가변 변수를 보호한다.
